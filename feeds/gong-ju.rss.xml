<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>兰湾</title><link href="http://st.avros.net/" rel="alternate"></link><link href="http://st.avros.net//feeds/gong-ju.rss.xml" rel="self"></link><id>http://st.avros.net/</id><updated>2016-03-16T00:00:00+08:00</updated><entry><title>修复宜家LED灯一则</title><link href="http://st.avros.net/articles/ikea_led.html" rel="alternate"></link><updated>2016-03-16T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2016-03-16:articles/ikea_led.html</id><summary type="html">&lt;p&gt;宜家买的LED灯不亮了。把线剪断，两边分别一测，发现LED是好的，电源适配器无输出，只得再给它做个驱动。&lt;/p&gt;
&lt;p&gt;LED需要恒流驱动，直接接个恒压输出的适配器上去是不行的，要么不亮，要么烧坏。串个电阻行不行呢？行是行，不过电阻会很热。这个LED灯是3W的，工作电流1A，接到5V电源上就需要串联2欧的电阻，电阻的发热量达到2W。这么做显然太不优雅。&lt;/p&gt;
&lt;p&gt;幸好手里还有若干LED驱动IC：华润的PT4115，用它可以顺便把调光功能也加上。画了个电路图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href="/images2/2016/ikea_led.png"&gt;&lt;img src="/images2/2016/ikea_led.png" width="500" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中R1用于设定LED工作电流，公式为&lt;span class="math"&gt;\(I_{\rm LED} = \frac{0.1}{R_1}\)&lt;/span&gt;. 电位器R2用于调光，从几百欧到几十kΩ的都可以用，这里用了拨轮式的音量电位器，好处是阻值按指数变化，这样LED亮度也按指数变化，会感觉实际亮度变化比较自然。&lt;/p&gt;
&lt;p&gt;LDO XC6206用于给PT4115的调光脚供电，用输出2.5V或3.3V的LDO都行。PT4115允许的输入电压范围是6~30V，但注意XC6206的输入电压最高只能到7V，因此只能用6~7V的电源供电。如果需要用更高输入电压的电源，可以把XC6206换成HT7133、MIC5207之类。&lt;/p&gt;
&lt;p&gt;电感L1用几十uH的功率电感就可以，注意饱和电流要大于1A。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript'; 
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary></entry><entry><title>利用Makefile实现avr-size -C的效果</title><link href="http://st.avros.net/articles/makefile_size.html" rel="alternate"></link><updated>2016-01-03T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2016-01-03:articles/makefile_size.html</id><summary type="html">&lt;p&gt;GNU工具链里的size大家应该都用过, 它可以显示elf/obj/exe/dll等可执行文件里各个段的大小, 非常方便. 加-A和-B参数分别是按sysv和berkeley格式显示, 默认带-B参数.&lt;/p&gt;
&lt;p&gt;avr-gcc里的avr-size则又增加了一个-C的选项, 可以显示单片机flash和ram的占用比例, 需要同时用--mcu参数指定avr单片机的型号, 效果是这样的:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;avr-size -C --mcu=attiny26 main.elf
AVR Memory Usage
----------------
Device: attiny26

Program:    1316 bytes (64.3% Full)
(.text + .data + .bootloader)

Data:         23 bytes (18.0% Full)
(.data + .bss + .noinit)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;是不是很方便? 可惜arm-gcc里的size并没有这个选项, 于是从avr转到stm32之后, 常常会感觉到不方便.&lt;/p&gt;
&lt;p&gt;后来发现, 只要在Makefile里all目标后面加上几行, 也能达到同样目的. 需要你的工具链里有sed和bc, sed用来从size的结果里截取包含数据的第二行, bc则用来作浮点运算.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;        @arr=(`$(TRGT)size $(PROJECT)_rom.elf | sed -n &amp;#39;2p&amp;#39;`); \
        let flash=($${arr[0]}+$${arr[1]}); \
        let mem=($${arr[1]}+$${arr[2]}); \
        let flash_size=$(subst K,,$(FLASH_SIZE))*1024; \
        let mem_size=$(subst K,,$(MEM_SIZE))*1024; \
        flash_usage=`echo &amp;quot;scale=1;($$flash*100/$$flash_size)&amp;quot; | bc`; \
        mem_usage=`echo &amp;quot;scale=1;($$mem*100/$$mem_size)&amp;quot; | bc`; \
        echo &amp;quot;Flash: $$flash / $$flash_size bytes, $$flash_usage% Full (.text + .data)&amp;quot;; \
        echo &amp;quot;SRAM:  $$mem / $$mem_size bytes, $$mem_usage% Full (.data + .bss)&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;效果如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;arm-none-eabi-size main_rom.elf
   text    data     bss     dec     hex filename
  34928    2212    5316   42456    a5d8 main_rom.elf
Flash: 37140 / 65536 bytes, 56.6% Full (.text + .data)
SRAM:  7528 / 8192 bytes, 91.8% Full (.data + .bss)
&lt;/pre&gt;&lt;/div&gt;</summary></entry><entry><title>最近的三个制作：酒酿机、6F22充电器、太阳能充电器</title><link href="http://st.avros.net/articles/fermetnter_6f22_solar.html" rel="alternate"></link><updated>2015-08-15T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2015-08-15:articles/fermetnter_6f22_solar.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;酒酿机&lt;/p&gt;
&lt;p&gt;做酒酿(醪醩)需要保持40度左右的温度发酵。正好家里有个最便宜的小熊酸奶机，不带控温功能的，能否用它来改装成酒酿机呢？&lt;/p&gt;
&lt;p&gt;把小熊酸奶机拆开一看，里面简单得一塌糊涂：铝板上装了个PTC电阻，直接接220V电源，作为发热器，旁边甩了两条线出来接前面板的指示灯。可以说毫无技术含量。于是把这些东西都拆掉，换成前几天做的PID控温电路。控温板上加了两个两位LED数码管，分别显示设定温度和实测温度，两个按键开关用来控温。加热器还是IRF530+LM35的配置。控温范围从35度到65度。&lt;/p&gt;
&lt;p&gt;发酵碗里装满水，放个温度计，开机一晚上实测……发现碗里的水温最终会比发热板的实测温度低15~20度。大概是因为发热板外面隔了一层塑料板，发酵碗又是一层塑料，两层塑料的热阻太大了。幸好温度已经能满足做酒酿的要求了。&lt;/p&gt;
&lt;p&gt;下次打算把LM35的引线接长一些，粘在发热板以外的塑料侧壁上，避免从发热板直接传导热量到LM35，这样效果也许会好些？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6F22充电器&lt;/p&gt;
&lt;p&gt;手里有两个可充电的6F22，但是一直没有好用的充电器。以前买过一个，拆开一看，里面实在是惨不忍睹，只好扔了。&lt;/p&gt;
&lt;p&gt;自己做了一个，电路图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href="/images2/2015/6f22_charger.png"&gt;&lt;img src="/images2/2015/6f22_charger.png" width="480" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;从USB输入的5V电压，用TP7660二倍压得到10V，再通过100欧电阻限流后给6F22充电。TL061接成比较器，一个输入端接电池正极，另一个输入端接100欧电阻和1k电阻分压得到的约9.1V电压。输出端接两个LED，分别表示正在充电和已经充满。之所以用TL061，一是因为@Tariel之前送了我不少，二是因为它的输入共模电压最高可以达到电源电压，这是一般运放不具备的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;太阳能充电器&lt;/p&gt;
&lt;p&gt;以前做的一个小台钟，用锂电池供电，充满一次电能工作半个月左右。但是半个月充一次电还是太麻烦，如果能利用太阳能给它充电，就省事多了。电路图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href="/images2/2015/solar_charger.png"&gt;&lt;img src="/images2/2015/solar_charger.png" width="480" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;就是PT1301的基本升压电路，输出电压为5.24V左右，再经过SS34降压后差不多是5V。等太阳能直射到书房了，看看效果如何。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary></entry><entry><title>PID控温实验</title><link href="http://st.avros.net/articles/pid_expr.html" rel="alternate"></link><updated>2015-07-13T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2015-07-13:articles/pid_expr.html</id><summary type="html">&lt;p&gt;做了个PID温控器，原理图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href="/images2/2015/pid_expr.png"&gt;&lt;img src="/images2/2015/pid_expr.png" width="480" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;电源电压首先流经0.33欧的取样电阻R1，然后给加热器供电。加热器用随便一个TO220封装的N沟道MOS管就行，LM35用来测温。高端电流检测虽然麻烦些，但这样加热器的连线可以更简单，四条线就够了。&lt;/p&gt;
&lt;p&gt;LM35输出的电压值经Mega48 AD转换后得到温度值。Mega48输出一路PWM经低通滤波后与取样电阻R1上的电压比较后控制MOS管的电流。之后用简单的PID算法即可实现控温了。&lt;/p&gt;
&lt;p&gt;把MOS管和LM35用导热胶粘在一块95mm x 66mm的散热片上，实测用12V 2A的电源供电时，开环加热可以达到44度左右。启用PID控温后，可以在室温~44度之间把温度控制到设定值正负0.1度。&lt;/p&gt;
&lt;p&gt;之后在这个基础上可以做很多东西了，比如酸奶机、酒酿机、煮温泉蛋机等等。&lt;/p&gt;</summary></entry><entry><title>最近的三个制作</title><link href="http://st.avros.net/articles/6f22_fm_rf.html" rel="alternate"></link><updated>2015-05-21T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2015-05-21:articles/6f22_fm_rf.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;彻底榨干6F22的剩余电量&lt;/p&gt;
&lt;p&gt;从万用表里拆下来的6F22常常还有许多电量没有用掉, 直接扔掉比较可惜. 把它DC-DC降压后给单片机之类供电, 还能再撑一段时间. &lt;/p&gt;
&lt;p&gt;电路如图, 就是AOZ1016的标准电路. 在它的EN脚对地接一个22uF的电解电容, 再对电源和对地各接一个轻触开关, 便实现了软开关. EN脚的输入电流极小, 靠22u电解就能维持工作几十分钟. EN脚拉低时, AOZ1016消耗电流仅1μA左右, 完全可以忽略不计了. DC-DC降压到3.68V左右, 再由XC6206稳压到3.3V.&lt;/p&gt;
&lt;p&gt;&lt;a href="/images2/2015/6f22.png"&gt;&lt;img src="/images2/2015/6f22.png" width="480" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;继续试验简易FM无线话筒&lt;/p&gt;
&lt;p&gt;话筒信号放大后直接推动与晶振串联的变容二极管, MMBT2222或S9018接成电容三点式振荡器, 谐振在晶振的三倍频上. 可惜这种方式能得到的频偏还是太小, 用收音机只能收到很微弱的信号. 下次试试锁相环调频吧.&lt;/p&gt;
&lt;p&gt;&lt;a href="/images2/2015/fm_caller_simple.png"&gt;&lt;img src="/images2/2015/fm_caller_simple.png" width="480" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RF功率计&lt;/p&gt;
&lt;p&gt;几年前Tariel/BH1PHL送了我一个50欧 100W的RF电阻, 一直没用上.&lt;/p&gt;
&lt;p&gt;这次用它做了个假负载+功率计, 从RF电阻上取电压, 检波、滤波后分压, 用mega48的adc采样, 显示在0801液晶屏上. &lt;/p&gt;
&lt;p&gt;&lt;a href="/images2/2015/rf_power_meter.png"&gt;&lt;img src="/images2/2015/rf_power_meter.png" width="480" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;一开始检波二极管用的是2SC1622的BC结, 结果实测在50M时功率严重偏小, 144M和430M就一点功率也测不到了. 换成1N60之后一切正常. 估计是因为2SC1622的结电容太大?&lt;/p&gt;
&lt;p&gt;但是1N60耐压太低, 只有50V, 这样只能测到峰值25V的RF电压, 换算成功率只有6.25W了. 下次还是得用先衰减再测的方案.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary></entry><entry><title>小台钟</title><link href="http://st.avros.net/articles/tiny24_clock.html" rel="alternate"></link><updated>2015-05-02T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2015-05-02:articles/tiny24_clock.html</id><summary type="html">&lt;p&gt;用手里闲置的Attiny24+LCD0801屏做了个小钟, 如图:&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/tiny24_clock.jpg" title="照片"&gt;&lt;img src="/images/tiny24_clock.jpg" width="500px" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用一节600还是800mAh的手机电池供电, 充满电可以工作半个月.&lt;/p&gt;
&lt;p&gt;原理图:&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/tiny24_clock_2.png" title="原理图"&gt;&lt;img src="/images/tiny24_clock_2.png" width="500px" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中LCD用的是0801, 和1602接口完全一样, 加了一块之前做的&lt;a href="articles/firefly&amp;amp;serlcd1602.html"&gt;串口转换小板&lt;/a&gt;. 由于是3.3V供电, LCD的V0脚需要接入负压, 这里负压用MCU的一路PWM经负倍压整流产生. 晶振用什么频率其实都无关紧要, 只要是个整数, 并且按一定的分频规则能凑出2Hz的频率就行了.&lt;/p&gt;
&lt;p&gt;源程序:&lt;/p&gt;
&lt;p&gt;&lt;a href="/files/tiny24_clock_src.7z"&gt;tiny24_clock_src.7z&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;改天再给它加个太阳能电池, 这样也许就再也不用充电了.&lt;/p&gt;</summary></entry><entry><title>在stm32上使用二进制字库的简单方法</title><link href="http://st.avros.net/articles/stm32_fonts.html" rel="alternate"></link><updated>2015-03-13T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2015-03-13:articles/stm32_fonts.html</id><summary type="html">&lt;p&gt;标题其实可以写成"在可执行程序里嵌入二进制资源的方法", 不过这个题目大了点, 还是原样吧.&lt;/p&gt;
&lt;p&gt;以前如果我们用到不带字库的点阵LCD, 一般都是把字库按16进制写成一个大数组, 再和其他源程序一起编译. 有没有方便一点的办法呢？这里给出两个方案.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用objcopy把字库转成目标文件(.o/.obj)&lt;/p&gt;
&lt;p&gt;假设我们需要嵌入的是5x7的ascii点阵字库, 文件名是asc5x7.bin.&lt;/p&gt;
&lt;p&gt;在arm-gcc环境下, 命令如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;arm-none-eabi-objcopy -B arm -I binary -O elf32-littlearm --rename-section .data=.rodata asc5x7.bin asc5x7.o
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要注意的是, objcopy生成的.o文件默认是把数据放在.data段的. 因此这里需要加个--rename-section的选项, 把.data改成.text或者.rodata, 不然单片机可怜的一点点RAM根本不够用. 如果是在PC上运行, 这里改不改就无所谓了, 不过内存还是能省点就省点的好.&lt;/p&gt;
&lt;p&gt;在.o里会生成三个符号: &lt;code&gt;_binary_asc5x7_bin_start, _binary_asc5x7_bin_end, binary_asc5x7_bin_size.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在程序里这么调用:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;extern const int _binary_asc5x7_bin_start;
uint8_t *start = (uint8_t *) (&amp;amp;_binary_asc5x7_bin_start);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样我们就得到了字库的起始地址. 在AVR上可能会稍复杂一些, 因为数据存储在FLASH里, 所以需要象PROGMEM数组一样, 用pgm_read_byte之类函数来读取.&lt;/p&gt;
&lt;p&gt;链接时会有一堆错误提示: "Conflicting CPU architectures ....", 这是因为.o里还缺少一个叫.ARM.attributes的段. 不过实际上也没啥影响, 程序是可以正确运行的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接利用GNU汇编的.incbin功能&lt;/p&gt;
&lt;p&gt;这是minux@bdwm提供的方法, 解决得明显更漂亮一些.&lt;/p&gt;
&lt;p&gt;首先建立一个asc5x7.s的源文件,内容如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="na"&gt;.section&lt;/span&gt; &lt;span class="no"&gt;.rodata&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="no"&gt;progbits&lt;/span&gt;
&lt;span class="na"&gt;.global&lt;/span&gt; &lt;span class="no"&gt;_binary_asc5x7_bin_start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;_binary_asc5x7_bin_end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;_binary_asc5x7_bin_size&lt;/span&gt;
&lt;span class="nl"&gt;_binary_asc5x7_bin_start:&lt;/span&gt;
&lt;span class="na"&gt;.incbin&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;asc5x7.bin&amp;quot;&lt;/span&gt;
&lt;span class="nl"&gt;_binary_asc5x7_bin_end:&lt;/span&gt;
&lt;span class="nf"&gt;_binary_asc5x7_bin_size&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="no"&gt;_binary_asc5x7_bin_end&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="no"&gt;_binary_asc5x7_bin_start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其实_binary_asc5x7_bin_size和_binary_asc5x7_bin_end这两个符号不要也可以, 因为字库的存储格式我们事先已经知道了.&lt;/p&gt;
&lt;p&gt;然后建立一个空的.c文件: &lt;code&gt;touch empty.c,  arm-none-eabi-gcc -S empty.c&lt;/code&gt;, 这样我们得到了一个empty.s, 内容如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; .cpu arm7tdmi-s
 .fpu softvfp
 .eabi_attribute 20, 1
 .eabi_attribute 21, 1
 .eabi_attribute 23, 3
 .eabi_attribute 24, 1
 .eabi_attribute 25, 1
 .eabi_attribute 26, 1
 .eabi_attribute 30, 6
 .eabi_attribute 18, 4
 .file     &amp;quot;empty.c&amp;quot;
 .ident     &amp;quot;GCC: (Sourcery G++ Lite 2011.03-42) 4.5.2&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把这些东西复制到之前那个asc5x7.s里, 部分内容可能要按需调整一下, 比如.cpu这里应该改成cortex-m0或者cortex-m3之类. 这样在链接时就不会出现前面那个"Conflicting CPU architectures ...."的报错信息了.&lt;/p&gt;
&lt;p&gt;如果要使用几个字库呢? 可以把它们全都放在一个段里, 但是如果只用到了某一个或几个字库, 也会把它们全都链接进去, 导致最终的可执行文件体积过大. 因此最好是拆成几个段. 假设我们用到了asc5x7.bin, asc12.bin, asc16.bin和asc24.bin, 写出来应该是这样:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="na"&gt;.section&lt;/span&gt; &lt;span class="no"&gt;.rodata.asc5x7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="no"&gt;progbits&lt;/span&gt;
&lt;span class="na"&gt;.global&lt;/span&gt; &lt;span class="no"&gt;_binary_asc5x7_bin_start&lt;/span&gt;
&lt;span class="nl"&gt;_binary_asc5x7_bin_start:&lt;/span&gt;
&lt;span class="na"&gt;.incbin&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;asc5x7.bin&amp;quot;&lt;/span&gt;

&lt;span class="na"&gt;.section&lt;/span&gt; &lt;span class="no"&gt;.rodata.asc12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="no"&gt;progbits&lt;/span&gt;
&lt;span class="na"&gt;.global&lt;/span&gt; &lt;span class="no"&gt;_binary_asc12_bin_start&lt;/span&gt;
&lt;span class="nl"&gt;_binary_asc12_bin_start:&lt;/span&gt;
&lt;span class="na"&gt;.incbin&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;asc12.bin&amp;quot;&lt;/span&gt;

&lt;span class="na"&gt;.section&lt;/span&gt; &lt;span class="no"&gt;.rodata.asc16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="no"&gt;progbits&lt;/span&gt;
&lt;span class="na"&gt;.global&lt;/span&gt; &lt;span class="no"&gt;_binary_asc16_bin_start&lt;/span&gt;
&lt;span class="nl"&gt;_binary_asc16_bin_start:&lt;/span&gt;
&lt;span class="na"&gt;.incbin&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;asc16.bin&amp;quot;&lt;/span&gt;

&lt;span class="na"&gt;.section&lt;/span&gt; &lt;span class="no"&gt;.rodata.asc24&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="no"&gt;progbits&lt;/span&gt;
&lt;span class="na"&gt;.global&lt;/span&gt; &lt;span class="no"&gt;_binary_asc24_bin_start&lt;/span&gt;
&lt;span class="nl"&gt;_binary_asc24_bin_start:&lt;/span&gt;
&lt;span class="na"&gt;.incbin&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;asc24.bin&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后Makefile里需要增加几个参数, 假如之前没有的话.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;CFLAGS += -ffunction-sections --data-sections,
LDFLAGS += -Wl,--gc-sections
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就只会把实际用到的段链接到最终可执行文件了.&lt;/p&gt;
&lt;p&gt;如果要在可执行文件里嵌入图片, 音频之类, 也可以用同样的方法.&lt;/p&gt;
&lt;p&gt;以上程序均在Windows 7 &amp;amp; Sourcery G++ &amp;amp; STM32F103/F030环境下测试通过. 在Keil/IAR等环境下请自行类推.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary></entry><entry><title>Sansei DMM2650背光改装记录</title><link href="http://st.avros.net/articles/dmm2650.html" rel="alternate"></link><updated>2014-12-12T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2014-12-12:articles/dmm2650.html</id><summary type="html">&lt;p&gt;Sansei DMM2650是80年代的小型台式四位半自动量程万用表, 在Diyers中一直很受欢迎. sunzx送了我一台, 相当好用. 使用过程中发现它有一个很大的不足之处就是液晶屏没有背光, 光线较暗时读数不容易看清, 所以我决定给它加装背光. &lt;/p&gt;
&lt;p&gt;&lt;a href="/images/dmm2650_1.jpg"&gt;&lt;img src="/images/dmm2650_1.jpg" width="500" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DMM2650的液晶屏是双列针脚直插式的, 小心地把它从插座上取下来, 如图：&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/dmm2650_2.jpg"&gt;&lt;img src="/images/dmm2650_2.jpg" width="500" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;背面贴了一层反光膜. 这层膜很致密, 用LED手电从背后照, 在前面基本看不到. 因此要加装背光, 必须把这层膜撕下来. &lt;/p&gt;
&lt;p&gt;&lt;a href="/images/dmm2650_3.jpg"&gt;&lt;img src="/images/dmm2650_3.jpg" width="500" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;撕的时候要很小心, 引脚碰弯了就不容易按回去了. &lt;/p&gt;
&lt;p&gt;&lt;a href="/images/dmm2650_4.jpg"&gt;&lt;img src="/images/dmm2650_4.jpg" width="500" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;接下来制作背光板. 这块2cm x 8cm的洞洞板长度长了点, 两端要锯掉一些. &lt;/p&gt;
&lt;p&gt;&lt;a href="/images/dmm2650_5.jpg"&gt;&lt;img src="/images/dmm2650_5.jpg" width="500" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;锯完之后, 尺寸正合适. &lt;/p&gt;
&lt;p&gt;&lt;a href="/images/dmm2650_6.jpg"&gt;&lt;img src="/images/dmm2650_6.jpg" width="500" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;在上面焊10个0805的白光LED, 以及相应的限流电阻. 背光不需要很亮, 大约0.5mA就足够, 这里限流电阻用了5.1K. &lt;/p&gt;
&lt;p&gt;&lt;a href="/images/dmm2650_7.jpg"&gt;&lt;img src="/images/dmm2650_7.jpg" width="500" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;点亮背光的效果. &lt;/p&gt;
&lt;p&gt;&lt;a href="/images/dmm2650_8.jpg"&gt;&lt;img src="/images/dmm2650_8.jpg" width="500" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;液晶屏插座正中是驱动芯片, 做好的背光板可以用双面胶贴在驱动芯片上. &lt;/p&gt;
&lt;p&gt;&lt;a href="/images/dmm2650_9.jpg"&gt;&lt;img src="/images/dmm2650_9.jpg" width="500" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;接下来要找到供电正负端, 很好找, 红色的电源开关最后面那两个引脚就是. 把背光板的引线缠在上面, 焊好. &lt;/p&gt;
&lt;p&gt;&lt;a href="/images/dmm2650_10.jpg"&gt;&lt;img src="/images/dmm2650_10.jpg" width="500" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;装回前面板, 开机! 怎么效果有点逗比……看来没有柔光片是不行的. &lt;/p&gt;
&lt;p&gt;&lt;a href="/images/dmm2650_11.jpg"&gt;&lt;img src="/images/dmm2650_11.jpg" width="500" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;柔光片这东西不好找, 试了不干胶贴纸的背纸、白色绝缘胶带、普通A4纸, 效果都不理想. 最后用快递盒子里的泡沫棉, 垫了两层, 好象稍微好点了. &lt;/p&gt;
&lt;p&gt;&lt;a href="/images/dmm2650_12.jpg"&gt;&lt;img src="/images/dmm2650_12.jpg" width="500" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;装回外壳, 放在书架上, 先凑和着用吧, 等以后找到了合适的柔光片再给它换上. &lt;/p&gt;
&lt;p&gt;&lt;a href="/images/dmm2650_13.jpg"&gt;&lt;img src="/images/dmm2650_13.jpg" width="500" /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;完~&lt;/p&gt;</summary></entry><entry><title>南瓜灯</title><link href="http://st.avros.net/articles/pumpkin_light.html" rel="alternate"></link><updated>2014-05-07T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2014-05-07:articles/pumpkin_light.html</id><summary type="html">&lt;p&gt;某次在超市看到有这种球形蜡烛头卖，如图：&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/pumpkin_1.jpg"&gt;&lt;img src="/images/pumpkin_1.jpg" width="500" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用记号笔把适当的地方涂黑，就成了这样：&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/pumpkin_2.jpg"&gt;&lt;img src="/images/pumpkin_2.jpg" width="500" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后呢，在它下面熔个洞，放进一个橙色大功率LED，点亮以后的效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/pumpkin_3.jpg"&gt;&lt;img src="/images/pumpkin_3.jpg" width="500" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好象万圣节的时间搞错了……不过无所谓啦。&lt;/p&gt;
&lt;p&gt;最后，用AVR让它的亮度忽明忽暗，尽可能象真正的蜡烛一样——其实挺困难的。&lt;/p&gt;</summary></entry><entry><title>滑动触摸实验</title><link href="http://st.avros.net/articles/slide_sense.html" rel="alternate"></link><updated>2013-07-14T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2013-07-14:articles/slide_sense.html</id><summary type="html">&lt;p&gt;见ST的两个应用笔记, AN2927和AN2896. 基本原理就是把触摸区域当作一个电容, 用一个IO口通过大电阻对触摸区域充放电, 另一个IO口来读取状态, 记录充放电时间. 当手指摸上去时, 这个电容变大了, 因此充放电时间会变长. &lt;/p&gt;
&lt;p&gt;&lt;a href="http://v.youku.com/v_show/id_XNTMzNTkxMDQ0.html" target="_blank"&gt;视频链接&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>萤火虫瓶子&amp;LCD1602串口转换板</title><link href="http://st.avros.net/articles/firefly&amp;serlcd1602.html" rel="alternate"></link><updated>2013-03-19T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2013-03-19:articles/firefly&amp;serlcd1602.html</id><summary type="html">&lt;p&gt;前者是用AVR的io口模拟PWM, 驱动8个LED闪亮. &lt;/p&gt;
&lt;p&gt;&lt;a href="http://v.youku.com/v_show/id_XNTI4Nzc4MDYw.html" target="_blank"&gt;视频链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;装到大玻璃瓶里, 关了灯看, 效果不错.&lt;/p&gt;
&lt;p&gt;分别试验了用PCF8574, 74HC164和用一片ATmega48实现用串口驱动1602液晶屏. &lt;/p&gt;
&lt;p&gt;PCF8574的方案很简单, 4个IO按4线法连接LCD高4位, 2个IO连接EN端和RS端. LCD RW直接接地, 用一只7660产生负压. 需要占用i2c口, 显示速度慢、性价比也低, 总之不推荐. &lt;/p&gt;
&lt;p&gt;用ATmega48扩展的话, 可以8线连接, 接口用i2c、spi、uart都可以, 用一个PWM口产生负压可以节省一只7660, 是最灵活的方式, 不过用uart时需要双方都有晶振. &lt;/p&gt;
&lt;p&gt;用74HC164要多占用两个IO, 不过用一些小技巧可以实现只占用两个GPIO：如图, 用电阻和二极管形成一个与门, 在串行写入数据时将最高位置1, 写完8bit后再拉高DATA端, 此时与门输出高电平, EN动作. 之后要拉低DATA, 连续八个CLK以清空164输出端, 避免影响下一轮. 实测写LCD快速、稳定, 成本也是三种方式里最低的. &lt;/p&gt;
&lt;p&gt;&lt;a href="/images/lcd_2wire.png" title="电路图"&gt;&lt;img src="/images/lcd_2wire.png" width="500px" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;后记: 后来还是觉得4线接法驱动LCD1602不太稳定. 继续改进, 改为用HC164的八个输出驱动LCD1602的全部8位数据接口, 输入端同时驱动RS脚, 同时再用一个IO来驱动EN脚. 总共用了三个IO, 不过稳定性好多了.&lt;/p&gt;</summary></entry><entry><title>USB温度计</title><link href="http://st.avros.net/articles/usb18b20.html" rel="alternate"></link><updated>2010-04-07T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2010-04-07:articles/usb18b20.html</id><summary type="html">&lt;p&gt;用ATMEGA8+DS18B20做了个USB接口的温度计, 插上电脑就能显示室内温度, 体积和一般的U盘差不多大.&lt;/p&gt;</summary></entry><entry><title>验钞笔</title><link href="http://st.avros.net/articles/cash_detector.html" rel="alternate"></link><updated>2010-03-27T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2010-03-27:articles/cash_detector.html</id><summary type="html">&lt;p&gt;拆了一支圆珠笔，粗细正好能装下一节7号锂电，利用原来的弹簧当触点。&lt;/p&gt;
&lt;p&gt;笔尖的位置装了一个5mm紫外LED，串27欧电阻限流。&lt;/p&gt;
&lt;p&gt;就这么简单！&lt;/p&gt;</summary></entry><entry><title>频率计</title><link href="http://st.avros.net/articles/freqmeter.html" rel="alternate"></link><updated>2009-10-15T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2009-10-15:articles/freqmeter.html</id><summary type="html">&lt;p&gt;输入信号经 K246 共源缓冲, 直耦到 C1959 放大,  74HC04 整形后通过另一只作为闸门的 C1959, 由 74HC393 和 Mega8 的 T1 计数器一起计数. 理论能测到 224=16.777216MHz.&lt;/p&gt;
&lt;p&gt;电路如图:&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/freqmeter.png" title="电路图"&gt;&lt;img src="/images/freqmeter.png" width="500px" /&gt;&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>分压电阻计算器</title><link href="http://st.avros.net/articles/res_divider.html" rel="alternate"></link><updated>2009-02-08T00:00:00+08:00</updated><author><name>Stavros</name></author><id>tag:st.avros.net,2009-02-08:articles/res_divider.html</id><summary type="html">&lt;p&gt;写了个计算DC-DC电路输出分压电阻的小工具, 如图.&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/res_divider.png" title="截图"&gt;&lt;img src="/images/res_divider.png" height="300px" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;输入所需要的电压和FB端参考电压, 它就自动计算出所需要的电阻值和误差, 电阻全部用5%精度的E24序列.&lt;/p&gt;
&lt;p&gt;下载链接:&lt;/p&gt;
&lt;p&gt;&lt;a href="/files/calc.zip"&gt;calc.zip&lt;/a&gt;&lt;/p&gt;</summary></entry></feed>